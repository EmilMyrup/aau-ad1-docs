# Introduction

In this lecture, we will talk about the administration of the course, a short
introduction to algorithms and algorithmic problems, two searching algorithms,
and the concepts about worst-case, average-case, and best-case running times.

<details>
  <summary>Show Lecture Slides</summary>
  <iframe
    src="https://www.moodle.aau.dk/pluginfile.php/1570716/mod_resource/content/13/Lecture-1.pdf"
    width="100%"
    height="500px"
  ></iframe>
</details>

## Exam

- Individual and written
- No electronic devices
- Paper-based materials
- Old fashion calculators
- Consist of two parts:
  1. Quizzes
  2. Open problems

## Algorithm overview

### Input instance

An **input instance** is a concrete example of the input e.g. $[2, 7, 1, 48]$.

## Problem Solving Procedure

Consists of three steps, but we will only cover two parts in this course, which
is **Analysis** and **Design**. We will not work with the _implementation_.

- Analysis

  - Specification
    - Input
    - Output

- Design
  - Algorithms
  - Data structures

## Data Structure

A data structure **stores** and **organizes** data. Furthermore, it facilitates access
and modifications. It can encapsulate different levels of abstraction, which means it
is possible to create different implementations.

## Data Structures vs. Algorithms

![Data structures vs. algorithms](/images/data-structures-vs-algorithms.png)

## Criteria for Algorithms

- Correctness

  - Definition
  - Incorrect algorithms
  - Approximate algorithms

- Complexity
  - Space
  - Time
  - Best cases, worst cases, and average cases

## Pseudo-Code

Is a description of algorithms, which consists of a mixture of code
and English. It is mostly formed form:

- Control structures
- Assigment ($\leftarrow$ or $=$)
- Array element acces: $A[i]$
- Composite type (record or object) element acces: $A.b$

## Exercises

### Two smallest numbers

> Write a pseudocode of an algorithm to find the two smallest numbers in a sequence of numbers (given as an array, and not sorted). What is the worst-case running time of your algorithm? Be careful to precisely define the input and the output of the algorithm.

```text
FIND-TWO-SMALLEST-NUMBERS(arr, arrSize)
  set first to index 1 in arr
  set second to index 2 in arr
  while i is less than arrSize do
    if i in arr is less than first
      set second to first
      set first to i
    else if i is less than second and i is not equal to first
      set second to i

  set sortedArray = [first, second]
  return sortedArray
```

Due to fact that the algorithm can find the two numbers in **one** traversal
the worst-case running time is $\mathcal{O}(n)$

### Reverse an array of numbers

> Write a pseudocode of an algorithm to reverse an array of numbers, i.e., the last element should become the first, next to last should become the second, etc. The algorithm should use only constant amount of extra space. What is the worst-case running time of your algorithm?

```text
REVERSE-ARRAY-OF-NUMBERS(arr, arrSize)
  set start to 0
  set end to arrSize-1
  while start is less than end do
    swap arr[start] with arr[end]
    increment start with 1
    decrement end with 1
  return arr
```

Worst-case complexity of this algorithm is $\mathcal{O}(\dfrac{n}{2})$ since we are swapping
the placement of elements on both sides of the middle.

### Check equality of sets

> Let A and B be two arrays sorted in non-decreasing order, each containing n numbers. Write a pseudocode of an algorithm to check whether the set of elements in A is equal to the set of elements in B, i.e., all elements of A are contained in B and vice versa. What is the worst-case running time of your algorithm?

```text
CHECK-EQUALITY-TWO-ARRAYS(A, B)
  set i to 0
  while A[i] equals B[i] and i is less than or equal to n do
    increment i with 1
  return i equals n
```

Worst-case complexity of this algorithm is $\mathcal{O}(n)$

### 1-1 Comparison of running times

> For each function $f(n)$ and time $t$ in the following table, determine the largest size $n$ of a problem that can be solved in time $t$, assuming that the algorithm to solve the problem takes $f(n)$ microseconds.

$$ \begin{array}{cc} & \text{1 second} & \text{1 minute} \\ \hline \lg n & 2^{10^6} & 2^{6 \times 10^7} & 2^{3.6 \times 10^9} & 2^{8.64 \times 10^{10}} & 2^{2.59 \times 10^{12}} & 2^{3.15 \times 10^{13}} & 2^{3.15 \times 10^{15}} \\ \sqrt n & 10^{12} & 3.6 \times 10^{15} & 1.3 \times 10^{19} & 7.46 \times 10^{21} & 6.72 \times 10^{24} & 9.95 \times 10^{26} & 9.95 \times 10^{30} \\ n & 10^6 & 6 \times 10^7 & 3.6 \times 10^9 & 8.64 \times 10^{10} & 2.59 \times 10^{12} & 3.15 \times 10^{13} & 3.15 \times 10^{15} \\ n\lg n & 6.24 \times 10^4 & 2.8 \times 10^6 & 1.33 \times 10^8 & 2.76 \times 10^9 & 7.19 \times 10^{10} & 7.98 \times 10^{11} & 6.86 \times 10^{13} \\ n^2 & 1000 & 7745 & 60000 & 293938 & 1609968 & 5615692 & 56156922 \\ n^3 & 100 & 391 & 1532 & 4420 & 13736 & 31593 & 146645 \\ 2^n & 19 & 25 & 31 & 36 & 41 & 44 & 51 \\ n! & 9 & 11 & 12 & 13 & 15 & 16 & 17 \end{array} $$

### 1.2-2 Smallest value of $$n$$

> Suppose we are comparing implementations of insertion sort and merge sort on the
> same machine. For inputs of size n, insertion sort runs in $8n^2$ steps, while merge
> sort runs in $64n*lg*n$ steps. For which values of n does insertion sort beat merge
> sort?
